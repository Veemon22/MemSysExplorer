"""
Memory Trace Viewer - Decode and display protobuf memory traces

This tool reads binary protobuf memory trace files generated by the MemSysExplorer
profilers and displays them in human-readable format.

Usage:
    python3 trace_viewer.py <trace_file.pb>
    
Requirements:
    pip install protobuf

To generate the protobuf Python bindings:
    protoc --python_out=. -I ../profilers/common/proto ../profilers/common/proto/memory_trace.proto
"""

import sys
import os
import argparse
from typing import List, Dict, Any

def generate_protobuf_bindings():
    """Generate Python protobuf bindings if they don't exist"""
    proto_file = "../profilers/common/proto/memory_trace.proto"
    pb2_file = "memory_trace_pb2.py"
    
    if not os.path.exists(pb2_file):
        print(f"Generating Python protobuf bindings from {proto_file}...")
        import subprocess
        try:
            subprocess.run([
                "protoc", 
                "--python_out=.", 
                f"-I{os.path.dirname(proto_file)}", 
                proto_file
            ], check=True)
            print(f"Generated {pb2_file}")
        except subprocess.CalledProcessError as e:
            print(f"Failed to generate protobuf bindings: {e}")
            print("Make sure protoc is installed: sudo apt-get install protobuf-compiler")
            return False
        except FileNotFoundError:
            print("protoc not found. Install with: sudo apt-get install protobuf-compiler")
            return False
    
    return True

def load_trace(filename: str):
    """Load and parse a memory trace file"""
    if not generate_protobuf_bindings():
        return None
        
    try:
        import memory_trace_pb2
    except ImportError:
        print("Could not import memory_trace_pb2. Run protoc to generate bindings.")
        return None
    
    trace = memory_trace_pb2.MemoryTrace()
    
    try:
        with open(filename, 'rb') as f:
            trace.ParseFromString(f.read())
        return trace
    except FileNotFoundError:
        print(f"Trace file not found: {filename}")
        return None
    except Exception as e:
        print(f"Failed to parse trace file: {e}")
        return None

def format_address(addr: int) -> str:
    """Format memory address as hex"""
    return f"0x{addr:08x}"

def format_timestamp(ts: int) -> str:
    """Format timestamp in nanoseconds"""
    if ts >= 1_000_000_000:  # >= 1 second
        return f"{ts/1_000_000_000:.3f}s"
    elif ts >= 1_000_000:    # >= 1 millisecond
        return f"{ts/1_000_000:.3f}ms"
    elif ts >= 1_000:        # >= 1 microsecond
        return f"{ts/1_000:.3f}Î¼s"
    else:
        return f"{ts}ns"

def get_mem_op_string(mem_op: int) -> str:
    """Convert memory operation enum to string"""
    return "READ " if mem_op == 0 else "WRITE"

def get_hit_miss_string(hit_miss: int) -> str:
    """Convert hit/miss enum to string"""
    return "HIT " if hit_miss == 0 else "MISS"

def analyze_trace(trace) -> Dict[str, Any]:
    """Analyze trace and compute statistics"""
    if not trace or not trace.events:
        return {}
    
    stats = {
        'total_events': len(trace.events),
        'reads': 0,
        'writes': 0,
        'hits': 0,
        'misses': 0,
        'threads': set(),
        'addresses': set(),
        'time_range': (float('inf'), 0),
        'address_range': (float('inf'), 0)
    }
    
    for event in trace.events:
        # Count operations
        if event.mem_op == 0:  # READ
            stats['reads'] += 1
        else:  # WRITE
            stats['writes'] += 1
            
        # Count hits/misses
        if event.hit_miss == 0:  # HIT
            stats['hits'] += 1
        else:  # MISS
            stats['misses'] += 1
        
        # Track threads and addresses
        stats['threads'].add(event.thread_id)
        stats['addresses'].add(event.address)
        
        # Time range
        stats['time_range'] = (
            min(stats['time_range'][0], event.timestamp),
            max(stats['time_range'][1], event.timestamp)
        )
        
        # Address range
        stats['address_range'] = (
            min(stats['address_range'][0], event.address),
            max(stats['address_range'][1], event.address)
        )
    
    # Convert sets to counts
    stats['unique_threads'] = len(stats['threads'])
    stats['unique_addresses'] = len(stats['addresses'])
    
    # Calculate rates
    stats['hit_rate'] = stats['hits'] / stats['total_events'] * 100
    stats['miss_rate'] = stats['misses'] / stats['total_events'] * 100
    
    return stats

def display_trace(trace, max_events: int = None, show_stats: bool = True):
    """Display trace in human-readable format"""
    if not trace:
        return
        
    print("Memory Trace Analysis")
    print("=" * 50)
    
    if show_stats:
        stats = analyze_trace(trace)
        if stats:
            print(f"\nStatistics:")
            print(f"   Total Events: {stats['total_events']}")
            print(f"   Reads/Writes: {stats['reads']}/{stats['writes']}")
            print(f"   Hits/Misses:  {stats['hits']}/{stats['misses']}")
            print(f"   Hit Rate:     {stats['hit_rate']:.1f}%")
            print(f"   Miss Rate:    {stats['miss_rate']:.1f}%")
            print(f"   Threads:      {stats['unique_threads']}")
            print(f"   Addresses:    {stats['unique_addresses']}")
            
            if stats['time_range'][0] != float('inf'):
                duration = stats['time_range'][1] - stats['time_range'][0]
                print(f"   Time Range:   {format_timestamp(stats['time_range'][0])} - {format_timestamp(stats['time_range'][1])}")
                print(f"   Duration:     {format_timestamp(duration)}")
            
            if stats['address_range'][0] != float('inf'):
                print(f"   Addr Range:   {format_address(stats['address_range'][0])} - {format_address(stats['address_range'][1])}")
    
    print(f"\nEvents:")
    print("   Time       Thread   Address    Op    Hit/Miss")
    print("   --------   ------   --------   ----  --------")
    
    events_to_show = trace.events[:max_events] if max_events else trace.events
    
    for i, event in enumerate(events_to_show):
        timestamp_str = f"{format_timestamp(event.timestamp):>10}"
        thread_str = f"{event.thread_id:>6}"
        address_str = f"{format_address(event.address):>10}"
        mem_op_str = f"{get_mem_op_string(event.mem_op):>5}"
        hit_miss_str = f"{get_hit_miss_string(event.hit_miss):>4}"
        
        print(f"   {timestamp_str} {thread_str} {address_str} {mem_op_str} {hit_miss_str}")
    
    if max_events and len(trace.events) > max_events:
        remaining = len(trace.events) - max_events
        print(f"   ... ({remaining} more events)")

def main():
    parser = argparse.ArgumentParser(description='View memory trace files')
    parser.add_argument('trace_file', help='Path to memory trace .pb file')
    parser.add_argument('-n', '--max-events', type=int, default=None, 
                        help='Maximum number of events to display')
    parser.add_argument('--no-stats', action='store_true', 
                        help='Skip statistics display')
    
    args = parser.parse_args()
    
    print(f"Loading trace file: {args.trace_file}")
    trace = load_trace(args.trace_file)
    
    if trace is None:
        return 1
        
    display_trace(trace, args.max_events, not args.no_stats)
    return 0

if __name__ == "__main__":
    sys.exit(main())
